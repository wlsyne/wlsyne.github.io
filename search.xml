<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>关于DOM的原生JS</title>
      <link href="/2018/09/29/%E5%85%B3%E4%BA%8EDOM%E7%9A%84%E5%8E%9F%E7%94%9FJS/"/>
      <url>/2018/09/29/%E5%85%B3%E4%BA%8EDOM%E7%9A%84%E5%8E%9F%E7%94%9FJS/</url>
      <content type="html"><![CDATA[<h3 id="原生JS操作DOM"><a href="#原生JS操作DOM" class="headerlink" title="原生JS操作DOM"></a>原生JS操作DOM</h3><h4 id="1-获取高度和滚动距离"><a href="#1-获取高度和滚动距离" class="headerlink" title="1.获取高度和滚动距离"></a>1.获取高度和滚动距离</h4><pre><code class="javascript">&lt;!-- 获取滚动距离 --&gt;document.documentElement.scrollTop //firefoxdocument.documentElement.scrollLeft //firefoxdocument.body.scrollTop //IEdocument.body.scrollLeft //IE&lt;!-- 获取窗口高度 --&gt;document.documentElement.clientHeight&lt;!-- 获取整个文档的高度 --&gt;document.documentElement.scrollHeight||document.body.scrollHeight</code></pre><h4 id="2-设置css"><a href="#2-设置css" class="headerlink" title="2.设置css"></a>2.设置css</h4><pre><code class="javascript">element.style.textAlign=center&lt;!-- 如果要设置!important --&gt;element.style.setProperty(&#39;height&#39;, &#39;300px&#39;, &#39;important&#39;);</code></pre>]]></content>
      
      <categories>
          
          <category> summary of dailywork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js正则表达式相关</title>
      <link href="/2018/09/26/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/09/26/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>RegExp 对象表示正则表达式，它是对字符串执行模式匹配的强大工具。</p><h4 id="1-RegExp正则表达式语法"><a href="#1-RegExp正则表达式语法" class="headerlink" title="1.RegExp正则表达式语法"></a>1.RegExp正则表达式语法</h4><pre><code class="javascript">/pattern/attributesnew RegExp(pattern, attributes)</code></pre><ul><li><strong>pattern:</strong>参数 pattern 是一个字符串，指定了正则表达式的模式或其他正则表达式。</li><li><strong>attributes:</strong>参数 attributes是修饰符，可选g、i、m。分别表示 <em>全局匹配、忽略大小写、多行匹配</em><h4 id="2-常用正则字符串"><a href="#2-常用正则字符串" class="headerlink" title="2.常用正则字符串"></a>2.常用正则字符串</h4></li><li>1.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\&nbsp;</span>:将下一个字符标记为一个特殊字符、或者一个元义字符、或一个向后引用、或一个八进制转义符</li><li>2.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;^&nbsp;</span>:匹配输入字符串的开始位置,^n匹配任何开头为n的字符串。</li><li>3.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;$&nbsp;</span>:匹配输入字符串的结束位置,n$匹配任何结尾为n的字符串。</li><li>4.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;<em>&nbsp;</em></span>:匹配前面的子表达式零次或多次,n匹配任何包含0个或多个n的字符串，等价于{0,}。</li><li>5.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;+&nbsp;</span>:匹配前面的子表达式一次或多次,n+匹配任何包含至少一个n的字符串，等价于{1,}</li><li>6.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;?&nbsp;</span>:匹配前面的子表达式零次或一次,n?匹配任何包含零个或一个n的字符串，等价于{0,1}</li><li>7.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;{n}&nbsp;</span>:n 是一个非负整数。匹配确定的 n 次,n{x}表示匹配包含 X 个 n 的序列的字符串。</li><li>8.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;{n,}&nbsp;</span>:n 是一个非负整数。匹配至少n次,n{x,}表示匹配包含至少X个 n 的序列的字符串。</li><li>9.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;{n,m}&nbsp;</span>:n 和 m 是一个非负整数。匹配至少n次最多匹配 m 次,n{x,y}表示匹配包含至少X个最多Y个 n 的序列的字符串。</li><li>10.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;?&nbsp;</span>:当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</li><li>11.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;x|y&nbsp;</span>:匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</li><li>12.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;[abc]&nbsp;</span>:字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</li><li>13.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;[^abc]&nbsp;</span>:负值字符集合。匹配未包含的任意字符。例如， [^abc] 可以匹配 “plain” 中的’p’。</li><li>14.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\b&nbsp;</span>:匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</li><li>15.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\B&nbsp;</span>:匹配一个非单词边界，也就是指单词和空格间的位置。例如， ‘er\B’ 不能匹配”never” 中的 ‘er’，但可以匹配 “verb” 中的 ‘er’。</li><li>16.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\d&nbsp;</span>:匹配一个数字字符</li><li>17.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\D&nbsp;</span>:匹配一个非数字字符</li><li>18.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\r&nbsp;</span>:匹配一个回车符</li><li>19.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\s&nbsp;</span>:匹配任何空白字符，包括空格、制表符、换页符等等</li><li>20.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\s&nbsp;</span>:匹配任何非空白字符</li><li>21.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\w&nbsp;</span>:匹配任何单词字符</li><li>22.<span style="background-color:rgb(241,231,231);color:rgb(184,14,61)">&nbsp;\W&nbsp;</span>:匹配任何非单词字符</li></ul><h4 id="3-正则表达式的方法"><a href="#3-正则表达式的方法" class="headerlink" title="3.正则表达式的方法"></a>3.正则表达式的方法</h4><ul><li><strong>exec()方法</strong>:该方法是专门为捕获组而设计的，其接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array的实例，但是包含两个额外的属性：index和input。其中index表示匹配项在字符串中的位置，而input表示应用字符串表达式的字符串。<pre><code class="javascript">  var text = &quot;mom and dad and baby&quot;;  var pattern = /mom( and dad( and baby)?)?/gi;  var matches = pattern.exec(text);  console.log(matches.index); //0  console.log(matches.input); //mom and dad and baby  console.log(matches[0]);    //mom and dad and baby 表示匹配到的字符串  console.log(matches[1]);    //and dad and baby 子表达式1匹配到的字符串  console.log(matches[2]);    //and baby 子表示2匹配到的字符串</code></pre></li><li><strong>test()方法</strong>:正则表达式常用方法test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true，否则返回false。<pre><code class="javascript">  //限定有两位小数的正实数   var reg=/^(0|[1-9][0-9]*)(\.[0-9]{2})?$/      console.log(reg.test(&#39;06.00&#39;)) //true</code></pre></li><li><strong>search()方法</strong>:在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回 -1<pre><code class="javascript">  var str = &#39;abcdef&#39;;  var re = /B/i;  alert( str.search(re) ); // 1</code></pre></li><li><strong>match()方法</strong>:获取正则匹配到的结果，以数组的形式返回<pre><code class="javascript">  &quot;186a619b28&quot;.match(/\d+/g); // [&quot;186&quot;,&quot;619&quot;,&quot;28&quot;] </code></pre></li><li><strong>replace()方法</strong>:这是正则表达式最常用的一个方法,replace 本身是JavaScript字符串对象的一个方法，它允许接收两个参数：replace([RegExp|String],[String|Function]),第1个参数可以是一个普通的字符串或是一个正则表达式,第2个参数可以是一个普通的字符串或是一个回调函数,如果第2个参数是回调函数，每匹配到一个结果就回调一次。<pre><code class="javascript">      var tel = `18306023285`      var reg3 = /(\d{3})(\d{4})(\d{4})/g      var tel = tel.replace(reg3, (...a) =&gt; {          console.log(a);          return `${a[1]}****${a[3]}`          //   参数内容          // 0.本次匹配到的字符串          // 1,...9: 正则表达式中有几个()，就会传递几个参数，1 9分别代表本次匹配中每个()提取的结果，最多9个          // offset:记录本次匹配的开始位置          // source:接受匹配的原始字符串      })      console.log(tel)</code></pre><h4 id="4-常用实例"><a href="#4-常用实例" class="headerlink" title="4.常用实例"></a>4.常用实例</h4></li><li>匹配第一个bat或者cat,不区分大小写： /[bc]at/i 或者 new RegExp(“[bc]at”,”i”);</li><li>匹配所有以”at”结尾的3个字符组合，不区分大小写：/.at/gi;</li><li>只能输入数字：^[0-9]*$;</li><li>只能输入n位的数字：^\d{n}$</li><li>只能输入n位的数字：^\d{n}$</li><li>只能输入至少n位的数字：^\d{n,}$</li><li>只能输入m~n位的数字：^\d{m,n}$</li><li>只能输入零和非零开头的数字：^(0|[1-9][0-9]*)$</li><li>只能输入有两位小数的正实数：^[0-9]+(.[0-9]{2})?$</li><li>只能输入有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$</li><li>只能输入非零的正整数：^+?[1-9][0-9]*$</li><li>只能输入长度为3的字符：^.{3}$</li><li>只能输入由26个英文字母组成的字符串：^[A-Za-z]+$</li><li>只能输入由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</li><li>只能输入由数字、26个英文字母或者下划线组成的字符串：^\w+$</li><li>验证用户密码：以字母开头，长度在6~18之间，只能包含字符、数字和下划线：^[a-zA-Z]\w{5,17}$</li><li>验证是否含有^%&amp;’,;=?$”等字符：[^%&amp;’,;=?$\x22]+</li><li>只能输入汉字：^[\u4e00-\u9fa5]{0,}$</li><li>验证Email地址：^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$</li><li>验证InternetURL：^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</li><li>验证身份证号（15位或18位数字）：^\d{15}|\d{18}$</li><li>验证IP地址：^((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$</li><li>匹配两个两个重叠出现的字符 例如，”aabbc11asd”， 返回结果为aa bb 11三组match：(\w)\1</li><li>匹配成对的HTML标签：&lt;(?<tag>[^\s&gt;]+)[^&gt;]<em>&gt;.</em>&lt;/\k<tag>&gt;</tag></tag></li><li>匹配1-58之间的数字：/^([1-9]|[1-5][0-8])$/</li><li>匹配 -90至90之间的整数（包括-90和90）：^(-?[1-8][0-9]|-?[1-9]|-?90|0)$</li><li>匹配收尾空白字符：^\s+|\s+$<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><a href="https://www.cnblogs.com/moqiutao/p/6513628.html" target="_blank" rel="noopener">js正则表达式详解</a></li></ul><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> summary of dailywork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RegExp对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>富文本的range对象与selection对象</title>
      <link href="/2018/07/23/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%8C%E4%B8%89/"/>
      <url>/2018/07/23/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%9A%84%E4%B8%80%E4%BA%8C%E4%B8%89/</url>
      <content type="html"><![CDATA[<p>因为之前做了一个听单配置的项目，涉及到富文本的一些API，所以就跟大家做一个简单的富文本的分享.<br>本次主要以加contenteditable为例</p><h3 id="1-富文本的selection对象"><a href="#1-富文本的selection对象" class="headerlink" title="1.富文本的selection对象"></a>1.富文本的selection对象</h3><h4 id="获取selection对象"><a href="#获取selection对象" class="headerlink" title="获取selection对象"></a>获取selection对象</h4><pre><code class="javascript"> window.getSelection() document.getSelection()</code></pre><p>在富文本编辑器中，使用getSelection()方法，可以确定实际选择的文本。这个方法是window对象和document对象的属性，调用它会返回一个表示当前选择文本的Selection对象。</p><h4 id="selection的属性"><a href="#selection的属性" class="headerlink" title="selection的属性"></a>selection的属性</h4><img src="/2018/07/23/富文本的一二三/sel1.png" class="osi" title="选区"><p><strong>anchorNode：</strong>Returns the Node in which the selection begins. </p><p><strong>anchorOffset：</strong>Returns a number representing the offset of the selection’s anchor within the anchorNode. If anchorNode is a text node, this is the number of characters within anchorNode preceding the anchor. If anchorNode is an element, this is the number of child nodes of the anchorNode preceding the anchor.</p><p><strong>focusNode：</strong>Returns the Node in which the selection ends.</p><p><strong>focusOffset：</strong>Returns a number representing the offset of the selection’s anchor within the focusNode. If focusNode is a text node, this is the number of characters within focusNode preceding the focus. If focusNode is an element, this is the number of child nodes of the focusNode preceding the focus.</p><p><strong>isCollapsed：</strong>Returns a Boolean indicating whether the selection’s start and end points are at the same position.</p><p><strong>rangeCount：</strong>Returns the number of ranges in the selection.</p><p><strong>type：</strong>Returns a DOMString describing the type of the current selection</p><h4 id="selection的方法"><a href="#selection的方法" class="headerlink" title="selection的方法"></a>selection的方法</h4><ul><li>1.Selection.addRange(range)<br>向选区（Selection）中添加一个区域（Range）<pre><code class="javascript">let strong = $(&#39;strong&#39;)let sle = window.getSelection()if (sle.rangeCount &gt; 0) {   sle.removeAllRanges()}let range = document.createRange();   range.selectNode(strong[0]);   sle.addRange(range);</code></pre></li><li>2.Selection.collapse(parentNode)<br> 这个方法方法可以收起当前选区到一个点。<pre><code class="javascript">let strong = $(&#39;strong&#39;)let sle = window.getSelection()  sle.collapse(strong[0]);</code></pre></li><li>3.Selection.collapseToEnd()<br>这个方法的作用是取消当前选区，并把光标定位在原选区的最末尾处<pre><code class="javascript">let sle = window.getSelection()  sle.collapseToEnd()</code></pre></li><li>4.Selection.collapseToStart()<br>这个方法的作用是取消当前选区，并把光标定位在原选区的最开始处<pre><code class="javascript">let sle = window.getSelection()  sle.collapseToStart()</code></pre></li><li>5.Selection.containsNode(aNode,aPartlyContained)<br>这个方法判断指定的节点是否包含在Selection中(是否被选中)<br><strong>aNode：</strong>需要判断是否被包含的节点<br><strong>aPartlyContained：</strong>布尔值，为true时，只要selection包含aNode的一部分就返回true,为false时，只有完全包含才返回true</li><li>6.Selection.deleteFromDocument()<br>这个方法用来删除选区里面的内容<pre><code class="javascript">let sle = window.getSelection()  sle.deleteFromDocument()</code></pre></li><li>7.Selection.extend(node, offset)<br><strong>node：</strong>焦点会被移至此节点内<br><strong>offset：</strong>在节点中的偏移量<br>方法移动选中区的焦点到指定的点。选中区的锚点不会移动。选中区将从锚点开始到新的焦点，不管方向。<pre><code class="javascript">let sle = window.getSelection()let $strong=$(&#39;strong&#39;)  sle.extend($strong[0])</code></pre></li><li>8.Selection.getRangeAt(index)<br><strong>index：</strong>该参数指定需要被处理的子集编号（从零开始计数）。如果该数值被错误的赋予了大于或等于 rangeCount 结果的数字，将会产生错误。<pre><code class="javascript">let sle = window.getSelection()let ranges=[]  for (let index = 0; index &lt; sle.rangeCount; index++) {      const element = sle.getRangeAt(index);      ranges.push(element)  }</code></pre></li><li>9.Selection.removeAllRanges()<br>这个方法会从当前selection对象中移除所有的range对象,取消所有的选择只 留下anchorNode 和focusNode属性并将其设置为null。<pre><code class="javascript">let strong = $(&#39;strong&#39;)let sle = window.getSelection()if (sle.rangeCount &gt; 0) {   sle.removeAllRanges()}let range = document.createRange();   range.selectNode(strong[0]);   sle.addRange(range);</code></pre></li><li>10.Selection.removeRange(range)<br>这个方法会从当前selection对象中移除传入的range对象,因为chrome只有一个range对象，所以就相当于Selection.removeAllRanges()</li><li>11.Selection.selectAllChildren(parentNode)<br><strong>parentNode：</strong>所有parentNode元素的子元素会被设为选中区域，parentNode本身除外。<pre><code class="javascript">let sle = window.getSelection()let $parent=$(&#39;.selected&#39;)  sle.selectAllChildren($parent[0])</code></pre></li><li>12.Selection.setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset)<br>这个方法是Selection接口用来选中并设置在两个特定的DOM节点中文本选中的范围, 并且选中的任何内容都位于两个节点之间.如果anchorNode和focusNode为同一元素则光标移动至该节点处<br>  <strong>anchorNode</strong>锚节点-选中内容的开始节点<br>  <strong>anchorOffset</strong>选中范围内起点位置在锚节点下第几个子节点的位置.例如,如果是值为0的话，整个节点都是被选中的. 如果值为1的话，那么至少整个节点至少有一个子节点被选中. 以此类推.<br>  <strong>focusNode</strong>焦点节点-选中内容的结尾节点<br>  <strong>focusOffset</strong>选中范围内结束位置在焦点节点下第几个子节点的位置.例如,如果是值为0的话，整个节点都是被选中的. 如果值为1的话，那么至少整个节点至少有一个子节点被选中. 以此类推.<pre><code class="javascript">let sle = window.getSelection()let $strong=$(&#39;strong&#39;)let $selected2=$(&#39;.selected2&#39;)sle.setBaseAndExtent($strong[0],0,$selected2[0],0)</code></pre></li><li>13.Selection.toString()<br>返回代表当前selection对象的字符串,例如当前选择的文本文字.<pre><code class="javascript">let sle = window.getSelection()sle.toString()</code></pre></li></ul><h3 id="2-富文本的range对象"><a href="#2-富文本的range对象" class="headerlink" title="2.富文本的range对象"></a>2.富文本的range对象</h3><p>Range表示包含节点和部分文本节点的文档片段</p><h4 id="获取range对象"><a href="#获取range对象" class="headerlink" title="获取range对象"></a>获取range对象</h4><ul><li>1.Document.createRange()</li><li>2.Selection.getRangeAt(index)</li><li>3.构造函数new Range()</li></ul><h4 id="range对象的属性"><a href="#range对象的属性" class="headerlink" title="range对象的属性"></a>range对象的属性</h4><img src="/2018/07/23/富文本的一二三/range.png" class="osi" title="range对象"><p><strong>collapsed：</strong>返回一个用于判断 Range 起始位置和终止位置是否相同的布尔值。<br><strong>commonAncestorContainer：</strong>返回包含 startContainer 和 endContainer 的最深的节点。<br><strong>endContainer：</strong>返回包含 Range 终点的节点。<br><strong>endOffset ：</strong>返回 endContainer 中表示Range终点位置的数字。如果 endContainer 的 Node 类型为 Text, Comment，或 CDATASection，偏移值是 endContainer 节点开头到 Range 末尾的总字符个数。对其他类型的 Node ， endOffset 指 endContainer 开头到 Range 末尾的总 Node 个数。这是个只读属性，要改变它， 请使用 Range.setEnd 方法。<br><strong>startContainer：</strong>返回包含 Range 开始的节点。<br><strong>startOffset ：</strong>返回 startContainer 中表示 Range 起始位置的数字。如果 startContainer 是一个文本（Text）、注释（Comment）或者CDATA区块（CDATASection）节点那么返回的偏移量是从 startContainer 开始到Range的边界点的距离。对于其他的节点类型， startOffset 返回 startContainer 到边界点的子元素数量。</p><h4 id="range对象的方法"><a href="#range对象的方法" class="headerlink" title="range对象的方法"></a>range对象的方法</h4><ul><li>1.Range.cloneContents()<br>这个方法返回一个克隆的节点<pre><code class="javascript">let sle = window.getSelection()let range=sle.getRangeAt(0)let dom=range.cloneContents()$(&#39;.richText1&#39;).append(dom);</code></pre></li><li>2.Range.cloneRange()<br>方法返回一个range对象，并且该对象的范围边界点与被克隆的range对象相同。克隆的对象是复制过来的，而非引用，所以这两个对象双方各自做出的改变，都不会影响另一方。<pre><code class="javascript">let sle = window.getSelection()let range=sle.getRangeAt(0)let cRange=range.cloneRange()</code></pre></li><li>3.Range.collapse(toStart)<br>这个方法用来折叠选区<br><strong>toStart：</strong>一个布尔值,true 折叠到 Range 的 start 节点，false 折叠到 end 节点。如果省略，则默认为 false<pre><code class="javascript">let sle = window.getSelection()let range=sle.getRangeAt(0)range.collapse(false)</code></pre></li><li>4.Range.compareBoundaryPoints(how, sourceRange)<br>这个方法用来和另一个选区来比较边界点<br>返回一个数字，-1、0、1中间的一个值，分别代表在前、相等、在后。<br><strong>how：</strong>有四个可选值<br><strong>Range.END_TO_END：</strong>对比sourceRange的结束边界点和range的结束边界点<br><strong>Range.END_TO_START：</strong>对比sourceRange的结束边界点和range的起始边界点<br><strong>Range.START_TO_END ：</strong>对比sourceRange的起始边界点和range的结束边界点<br><strong>Range.START_TO_END ：</strong>对比sourceRange的起始边界点和range的起始边界点<br><strong>sourceRange：</strong>对比的range<pre><code class="javascript">let sle = window.getSelection()let range=sle.getRangeAt(0)let cRange=range.cloneRange()let compare=range.compareBoundaryPoints(Range.END_TO_END,cRange)  console.log(compare)</code></pre></li><li>5.Range.comparePoint(referenceNode, offset)<br>这个方法用来比较节点和range的位置<br>返回一个数字，-1、0、1中间的一个值，分别代表在前、相等、在后。<br><strong>referenceNode：</strong>对比的节点<br><strong>offset：</strong>如果referenceNode是Text, Comment, 或者 CDATASection中的一种，offset代表referenceNode里面的字符数量，对于其他类型的节点，offset代表其子节点数量<pre><code class="javascript">let sle = window.getSelection()let range=sle.getRangeAt(0)let compare=range.comparePoint($strong[0],0)  console.log(compare)</code></pre></li><li>6.Range.createContextualFragment(tagString)<br>这个方法返回一个文档片段，相当于把string转换成一个文档片段对象，但是感觉这个没什么用很多api都能够做到<br><strong>tagString：</strong>将要转换成文档片段的字符串<pre><code class="javascript">let toString=&quot;&lt;span&gt;一支穿云箭，千军万马来相见&lt;/span&gt;&quot;let range=document.createRange()range.selectNode($selected2[0])let doc=range.createContextualFragment(toString)console.log(doc)$(&#39;.richText1&#39;).append(doc);$(&#39;.richText1&#39;).append(toString);</code></pre></li><li>7.Range.deleteContents()<br>这个方法用来移除range的内容,这个方法跟Selection.deleteFromDocument()很相似，都是移除内容的<pre><code class="javascript">let range=sle.getRangeAt(0)  range.deleteContents()</code></pre></li><li>8.Range.extractContents()<br>方法移动了Range 中的内容从文档树到DocumentFragment（文档片段对象），这个方法会改变文档的布局<pre><code class="javascript">let range=sle.getRangeAt(0)  range.deleteContents()</code></pre></li><li>9.Range.getBoundingClientRect()<br>返回一个 DOMRect 对象，该对象限定了选定的文档对象的内容，该方法返回了一个矩形，这个矩形包围了该文档对象中所有元素的边界矩形集合<img src="/2018/07/23/富文本的一二三/rect.png" class="osi" title="rect对象">  <strong>width：</strong>矩形的宽度<br>  <strong>height：</strong>矩形的高度<br>  <strong>left：</strong>矩形的左边与文档左边的距离<br>  <strong>right：</strong>矩形的右边与文档左边的距离<br>  <strong>top：</strong>矩形的上边与文档上边的距离<br>  <strong>bottom：</strong>矩形的下边与文档上边的距离<br>  <strong>x：</strong>矩形的左上角与文档右边的距离<br>  <strong>y：</strong>矩形的左上角与文档上边的距离<pre><code class="javascript">let range=sle.getRangeAt(0)let rect=range.getBoundingClientRect()  console.log(rect)</code></pre></li><li>10.Range.getClientRects()<br>跟上面的方法不同这个方法返回的是一个边界矩形的LIST，而上面的方法返回的是一个矩形包含所有range里面的元素<pre><code class="javascript">let range=sle.getRangeAt(0)let rect=range.getClientRects()  console.log(rect)</code></pre></li><li>11.Range.insertNode(newNode)<br>将一个node节点插入range的起始位置<br><strong>newNode：</strong>要插入的节点<pre><code class="javascript">let range=sle.getRangeAt(0)let dom=document.createTextNode(&#39;春江潮水连海平，海上明月共潮生&#39;)range.insertNode(dom)</code></pre></li><li>12.Range.intersectsNode(referenceNode)<br>返回一个布尔值，用来反映传入的node是否包含或者相交在range里面<pre><code class="javascript">let range=sle.getRangeAt(0)let dom=document.createTextNode(&#39;春江潮水连海平，海上明月共潮生&#39;)range.insertNode(dom)</code></pre></li><li>13.Range.isPointInRange(referenceNode, offset)<br>这个节点返回一个布尔值，反应指定的Point是否在这个节点中，运用在textNode中效果比较明显<pre><code class="javascript">let range=sle.getRangeAt(0)let bool=range.isPointInRange($strong[0].childNodes[0],0)console.log(bool)</code></pre></li><li>14.Range.selectNode(referenceNode)<br>这个方法可以使range包含整个referenceNode<pre><code class="javascript">let range=sle.getRangeAt(0)  range.selectNode($strong[0])</code></pre></li><li>15.Range.selectNodeContents(referenceNode)<br>方法设置 Range 使其包含一个 Node 的内容，这个方法和上面的selectNode很相似<pre><code class="javascript">let range=sle.getRangeAt(0)  range.selectNode($strong[0])</code></pre></li><li>16.Range.setEnd(endNode, endOffset)<br>方法用于设置 Range的结束位置<br><strong>endNode：</strong>endNode用于设定 Range的结束位置<br><strong>endOffset：</strong>必须为不小于0的整数。表示从endNode的结束位置算起的偏移量<pre><code class="javascript">let range=sle.getRangeAt(0)  range.setEnd($parent[0],2)</code></pre></li><li>16.Range.setEndAfter(referenceNode)<br>这个方法会将range的终点节点设为referenceNode之后<pre><code class="javascript">let range=sle.getRangeAt(0)  range.setEndAfter($parent[0])</code></pre></li><li>17.Range.setEndBefore(referenceNode)<br>跟上面的api相反，这个方法会将终点节点设为referenceNode之前<pre><code class="javascript">let range=sle.getRangeAt(0)  range.setEndAfter($parent[0])</code></pre></li><li>18.Range.setStart(startNode, startOffset)<br>方法用于设置 Range的起始位置<br><strong>endNode：</strong>endNode用于设定 Range的起始位置<br><strong>endOffset：</strong>必须为不小于0的整数。表示从endNode的起始位置算起的偏移量<pre><code class="javascript">let range=sle.getRangeAt(0)  range.setEndAfter($parent[0],0)</code></pre></li><li>19.Range.setStartAfter(referenceNode)<br>这个方法会将range的起始节点设为referenceNode之后<pre><code class="javascript">let range=sle.getRangeAt(0)  range.setEndAfter($parent[0])</code></pre></li><li>20.Range.setStartBefore(referenceNode)<br>这个方法会将range的起始节点设为referenceNode之前<pre><code class="javascript">let range=sle.getRangeAt(0)  range.setStartBefore($parent[0])</code></pre></li><li>21.Range.surroundContents(newNode)<br>这个方法将Range对象的内容移动到一个新的节点, 并将这个新节点放到指定区域.<pre><code class="javascript">let red=document.createElement(&#39;strong&#39;)  let range=sle.getRangeAt(0)  range.surroundContents(red)</code></pre></li><li>22.Range.toString()<br>这个方法返回一个string,内容为range的text<pre><code class="javascript">  let range=sle.getRangeAt(0)  range.toString()</code></pre></li></ul><h3 id="3-常用的api"><a href="#3-常用的api" class="headerlink" title="3.常用的api"></a>3.常用的api</h3><ul><li>折叠选区<br>1.Selection.collapse(parentNode)<br>2.Selection.collapseToEnd()<br>3.Selection.collapseToStart()<br>4.Range.collapse(toStart)</li><li>移动光标/选区<br>1.Selection.addRange(range)<br>2.Selection.setBaseAndExtent(anchorNode,anchorOffset,focusNode,focusOffset)<br>3.Range.selectNode(referenceNode)<br>4.Range.selectNodeContents(referenceNode)<br>5.Range.setEnd(endNode, endOffset)<br>6.Range.setEndAfter(referenceNode)<br>7.Range.setStartBefore(referenceNode)</li><li>转移文本<br>Range.surroundContents(newNode)</li></ul><p><a href="https://github.com/wlsyne/wysiwyg" target="_blank" rel="noopener">demo地址</a></p><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> summary of dailywork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 富文本API </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web性能权威指南》读书笔记---sixth</title>
      <link href="/2018/07/10/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sixth/"/>
      <url>/2018/07/10/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-sixth/</url>
      <content type="html"><![CDATA[<blockquote><p>合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。</p><footer><strong>《Web性能权威指南》</strong><cite>——Ilya Grigorik</cite></footer></blockquote><h4 id="第六章-Wi-Fi"><a href="#第六章-Wi-Fi" class="headerlink" title="第六章 Wi-Fi"></a>第六章 Wi-Fi</h4><p>Wi-Fi工作于免许可的ISM频段，并且部署容易，硬件便宜。Wi-Fi已经是如今最流行也是应用的最为广泛的无线技术。</p><h6 id="6-1-从以太网到无线局域网"><a href="#6-1-从以太网到无线局域网" class="headerlink" title="6.1 从以太网到无线局域网"></a>6.1 从以太网到无线局域网</h6><p>802.11无线标准主要是作为已有的以太网标准（802.3）的扩展来设计的。</p><p>以太网通常被称作局域网（LAN）标准，而802.11标准则常备称作无线局域网（WLAN，Wireless LAN）标准。</p><p>事实上，以太网和Wi-Fi都把 <strong>共享媒体（无论是线缆还是无线电波）</strong>视为随机访问通道，没有中心控制环节，也没有调度中心调度中心控制谁或者哪台设备在哪个时刻发送数据。所有设备都自我控制，大家必须协同工作，共同维护共享信道的性能。</p><p>以太网标准过去依赖于概率访问的CSMA（Carrier Sense Multiple Access，载波监听多路访问）协议，实际上就是一个先听后说的一种算法：</p><ul><li>检查是否有人正在发送</li><li>如果信道忙，监听并等待信道空闲</li><li>信道空闲后，立即发送数据</li></ul><p>但是，任何信号传播都需要时间，冲突也时有发生。为此以太网标准增加了冲突检测机制（CSMA/CD，Collision Detection）：</p><ul><li>如果检测到冲突，则双方都立即停止发送数据并小睡一段随机时间（后续时间以指数增长），从而保证发生冲突的发送端不会同步，而且不会同时开始发送数据</li></ul><p>Wi-Fi处理冲突的方式很类似，但也稍有不同：由于收发无线电的硬件所限，它不能在发送数据时期检测到冲突。<br>Wi-Fi采用的是冲突避免（CSMA/CA,Collision Avoidance）机制，即每个发送方都会在自己认为信道空闲时发送数据。为此，每个Wi-Fi数据帧必须明确得到接收方的确认，以保证不发生冲突。</p><p>实践中，概率访问模型（CSMA）在轻负载网络中表现很好。但是要保证良好的信道通信率，则信道负载必须低于10%，保持低负载的情况下，不用太多协调和调度就能获得理想的吞吐能力。</p><h6 id="6-2-Wi-Fi标准及功能"><a href="#6-2-Wi-Fi标准及功能" class="headerlink" title="6.2 Wi-Fi标准及功能"></a>6.2 Wi-Fi标准及功能</h6><p>Wi-Fi发布历史路线图：</p><table><thead><tr><th>802.11协议</th><th>发布时间</th><th>频率（GHz）</th><th>带宽（MHz）</th><th>流速率（Mbit/s）</th></tr></thead><tbody><tr><td>b</td><td>1999-09</td><td>2.4</td><td>20</td><td>1、2、5.5、11</td></tr><tr><td>g</td><td>2003-06</td><td>2.4</td><td>20</td><td>6、9、12、18、24、36、48、54</td></tr><tr><td>n</td><td>2009-10</td><td>2.4</td><td>20</td><td>7.2、14.4、21.7、28.9、43.3、57.8、65、72.2</td></tr><tr><td>n</td><td>2009-10</td><td>5</td><td>40</td><td>15、30、45、60、90、120、135、150</td></tr><tr><td>ac</td><td>2014年前后</td><td>5</td><td>20、40、80、160</td><td>最高866.7</td></tr></tbody></table><p>n和ac标准将每个信道的带宽由20MHz提升到了40MHz，使用高阶调制算法，增加无线信道并行发射多个数据流。</p><h6 id="6-3-测量和优化Wi-Fi性能"><a href="#6-3-测量和优化Wi-Fi性能" class="headerlink" title="6.3 测量和优化Wi-Fi性能"></a>6.3 测量和优化Wi-Fi性能</h6><p>上述所说的所有的所有速度都是理论上的速度，你的Wi-Fi吞吐量的大小会受限于小区内部和外部的干扰，连接在相同Wi-Fi节点上的分流，以及相同频率Wi-Fi对信道的干扰等等。</p><p>新的WMM（Wi-Fi Multimedia，Wi-Fi多媒体）扩展会在无线电接口中对需要低延迟的应用（语音、视频等）启用QoS（Quality of Service，服务质量），但能识别的路由器很少，能识别的客户端就更少了。与此同时，你的网络内部和附近的Wi-Fi网络一定会争用相同频率的无线电信道资源。</p><p>使用最多的2.4GHz频段提供3个不重叠的20MHz的无线电信道，当然并不是所有的国家都这样分配，某些国家可能允许使用更高的信道。但是你的Wi-Fi网络周围绝对不止两三个Wi-Fi网络，其中一些一定会重叠从而共享相同频率范围内的带宽。</p><p>可以采用的一个建议：<br>新的802.11n和802.11ac标准使用5GHz频段，不仅拓宽了频率范围，而且能保证在多数环境下不发生冲突。如果使用双频路由器（支持2.4 GHz和5 GHz），这样就可以解决频率占用的问题。</p><p>综上所诉：</p><ul><li>Wi-Fi不保证用户的带宽和延迟时间。</li><li>Wi-Fi的信噪比不同，带宽也随之不同。</li><li>Wi-Fi的发射功率被限制在200mW以内</li><li>Wi-Fi在2.4 GHz和5 GHz频段中的频谱有限</li><li>Wi-Fi信道分配决定了接入点信号会重叠。</li><li>Wi-F接入点与客户端争用同一个无线信道。</li></ul><p style="color:rgb(250,150,150)">PS:总之如果你是跟其他人共享一个接入点，而且近旁还有其他的Wi-Fi网络，那么你的带宽和延迟都会高度不稳定</p><h6 id="6-4-针对Wi-Fi的优化建议"><a href="#6-4-针对Wi-Fi的优化建议" class="headerlink" title="6.4 针对Wi-Fi的优化建议"></a>6.4 针对Wi-Fi的优化建议</h6><p><strong>适应可变带宽：</strong><br>自适应比特流，来主动适应带宽变化。<br>举个例子：你在视频网站上看电影，但是带宽很不稳定，一会快一会慢，如果按照固定的带宽加载固定质量的视频，如果网络变化就会形成卡顿，导致断断续续的卡顿。<br>YouTube的解决方法是将视频分成5-10s的块，然后客户端加载视频的期间，客户端或者服务器可以监控每个视频块的加载时间，据此调整下一个视频块的质量。</p><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> Reading notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Web性能权威指南》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web性能权威指南》读书笔记---fifth</title>
      <link href="/2018/07/09/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-fifth/"/>
      <url>/2018/07/09/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-fifth/</url>
      <content type="html"><![CDATA[<blockquote><p>合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。</p><footer><strong>《Web性能权威指南》</strong><cite>——Ilya Grigorik</cite></footer></blockquote><h4 id="第五章-无线网络概览"><a href="#第五章-无线网络概览" class="headerlink" title="第五章 无线网络概览"></a>第五章 无线网络概览</h4><h6 id="5-1-无所不在的连接"><a href="#5-1-无所不在的连接" class="headerlink" title="5.1 无所不在的连接"></a>5.1 无所不在的连接</h6><p>过去十年间，最具颠覆性的技术趋势非随时随地上网莫属，人们对随时随地上网的需求也日益增加。<br>无线网络是这股趋势的核心所在。宽泛的说，无线网络可以指任何不通过线缆连接的网络，只有不通过线缆才能满足移动用户随时随地上网的需求。面对多样的使用场景和应用形式，无线技术自然也会多种多样。Wi-Fi、蓝牙、ZigBee、NFC、WiMax、LTE、HSPA、EVDO，以及早先应用的3G标准、卫星服务等等，都是我们今天常用的无线网络技术。<br>但是尽管无线传输数据与有线传输数据有着本质上的差别，但是用户期待的体验都是一样的。</p><h6 id="5-2-无所不在的连接"><a href="#5-2-无所不在的连接" class="headerlink" title="5.2 无所不在的连接"></a>5.2 无所不在的连接</h6><p>无线网络的类型：</p><table><thead><tr><th>类型</th><th>范围</th><th>应用</th><th>标准</th></tr></thead><tbody><tr><td>个人局域网（PAN）</td><td>个人活动范围内</td><td>替代周边设备的线缆</td><td>蓝牙、ZigBee、NFC</td></tr><tr><td>局域网（LAN）</td><td>一栋楼或者校园内</td><td>有线网络的无限扩展</td><td>IEEE 802.11（Wi-Fi）</td></tr><tr><td>城域网（MAN）</td><td>一座城市内</td><td>无线内联网</td><td>IEEE 802.15（WiMax）</td></tr><tr><td>广域网（WAN）</td><td>世界范围内</td><td>无线网络</td><td>蜂窝（UMTS、LTE等）</td></tr></tbody></table><p>你的下一个应用可能要通过移动网络支付，他同时可能还要通过NFC付款、通过蓝牙实现WebRTC的P2P通信、通过Wi-Fi传输高清视频流。所以无线应用不可能局限于一种无线标准。</p><h6 id="5-3-无线网络的性能基础"><a href="#5-3-无线网络的性能基础" class="headerlink" title="5.3 无线网络的性能基础"></a>5.3 无线网络的性能基础</h6><p>所有无线技术都有自身的约束和局限。然而，无论使用哪种无线技术，所有的通信方法都有一个最大的信道容量，这个容量是由相同的底层原理决定的。</p><p>C=BW*log<sub>2</sub>(1+S/N)</p><ul><li>C是信道容量，单位是bit/s</li><li>BW是可用带宽，单位是HZ</li><li>S是信号，N是噪声，单位是W</li></ul><p>尽管这个数学模型存在一定的简化，但是我们可以看出，<strong>与传输速度最直接相关的就是接收端与发送端之间的可用带宽与信号长度</strong></p><h6 id="5-3-1-带宽"><a href="#5-3-1-带宽" class="headerlink" title="5.3.1 带宽"></a>5.3.1 带宽</h6><p>有线网络通过线缆将网络中的各个节点连接在一起，而无线电通信的本质则是一个共享媒体，他靠的是无线电波，或者叫做电磁辐射。<br>为实现通信，发送端和接收端必须事先就通信使用的频率范围达成共识，在这个频率范围内双方可以顺畅的交换信息。<br>这些频率范围的确定与分配是由地方政府负责的。由于政府规定不同，有些无线技术可以在世界上某些国家和地区使用，但在另一些国家和地区就不能使用。<br>除了以共有频段作为信息交互的基础外，影响性能的最主要的因素就是频率范围的大小（带宽）。根据上面的数学模型，信道的总体比特率与可用带宽成正比，所以提高带宽则可以显著提升性能。<br>但是，并非所有的频率范围的性能都一样。低频信号传输距离远、覆盖范围广（大蜂窝），但是要求天线更大，而且竞争激烈。另一方面，高频信号能够传输更多数据，但是传输距离不远，因此覆盖范围小（小蜂窝），需要较多的基础设施投入。</p><p style="color:rgb(250,150,150)">PS:对不同的应用而言，不同的频率范围价值也不一样。广播只适合低频率范围，而双向通信则更适合使用较小的蜂窝，因为较小的蜂窝能提供更高的带宽，竞争也更少</p><h6 id="5-3-2-信号强度"><a href="#5-3-2-信号强度" class="headerlink" title="5.3.2 信号强度"></a>5.3.2 信号强度</h6><p>收发端之间的信号强度，也叫做信噪比（SNR，Signal Noise Ratio），信噪比衡量的是预期信号强度与背景噪声及干扰之间的比值。背景噪声越大，携带信息的信号就必须越强。<br>本质上，所有无线电使用的都是共享媒体，因此别的设备很可能在这个媒体中产生干扰信号。比如，以2.5GHz频率工作的微波炉和可能与Wi-Fi使用的频率范围重合，从而产生交叉干扰。<br>因此，如果想要在存在干扰的情况下达到预期的数据传输速度，要么增大信号强度，要么缩短收发两端的距离，或者双管齐下。</p><h6 id="5-3-3-调制"><a href="#5-3-3-调制" class="headerlink" title="5.3.3 调制"></a>5.3.3 调制</h6><p>除了可用带宽和SNR（信噪比）之外，用于编码信号的算法对无线性能同样有显著影响。<br>简单来说，我们的数字信号（1和0）需要转换成模拟信号（无线电波）。<strong>调制</strong>就是这个数模转换过程，不同的调制算法的转换效率是不一样的。不同的字母数字组合与符号率决定了信道的最终吞吐量。</p><h6 id="5-4-测量现实中的无线性能"><a href="#5-4-测量现实中的无线性能" class="headerlink" title="5.4 测量现实中的无线性能"></a>5.4 测量现实中的无线性能</h6><p>所有无线通信的特点：</p><ul><li>通过共享的通信媒体（无线电波）实现；</li><li>在管制下使用特定频率范围；</li><li>在管制下使用特定的发射功率；</li><li>受限于不断变化的背景噪声和干扰；</li><li>受限于所选无线技术的技术约束；</li><li>受限于设备本身的限制，比如形状、电源，等等</li></ul><p>影响无线网络性能的因素：</p><ul><li>收发端的距离；</li><li>当前位置的背景噪声大小；</li><li>来自同一网络的其他用户的干扰大小</li><li>来自相邻网络的其他用户的干扰大小</li><li>两端发射功率大小</li><li>处理能力及调制算法</li></ul><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> Reading notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Web性能权威指南》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web性能权威指南》读书笔记---fourth</title>
      <link href="/2018/07/04/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-fourth/"/>
      <url>/2018/07/04/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-fourth/</url>
      <content type="html"><![CDATA[<blockquote><p>合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。</p><footer><strong>《Web性能权威指南》</strong><cite>——Ilya Grigorik</cite></footer></blockquote><h4 id="第四章-传输层安全（TLS）"><a href="#第四章-传输层安全（TLS）" class="headerlink" title="第四章 传输层安全（TLS）"></a>第四章 传输层安全（TLS）</h4><p><strong>核心概念</strong></p><ul><li><strong>SSL：</strong>Secure Socket Layer,安全套接字层，协 议最初是v网景公司为了保障网上交易安全而开发的，该协议通过加密来保护客户个人资料，通过认证和完整性检查来确保交易安全。</li><li><strong>TLS：</strong>Transport Layer Security，传输层安全。鉴于SSL是网景公司专有的，IETF成立了一个小组负责标准化该协议，即RFC 2246，即TLS 1.0，也就是SSL 3.0的升级版。<p style="color:rgb(250,150,150)">PS：SSL协议和TLS协议在应用层实现。但是不会影响上层协议，也就是应用层，但能够保证上层协议的网络通信安全<br>在正确使用的情况下，第三方监听者只能够推断出连接的端口、加密类型和发送数据的频率和大致数量，不能实际读取和修改任何数据。</p></li></ul><h6 id="4-1-加密、身份验证与完整性"><a href="#4-1-加密、身份验证与完整性" class="headerlink" title="4.1 加密、身份验证与完整性"></a>4.1 加密、身份验证与完整性</h6><p>TLS协议的目标是为在他之上运行的应用提供三个基本服务：加密、身份验证和数据完整性。</p><ul><li><em>加密</em><br>混淆数据的机制</li><li><em>身份验证</em><br>验证身份标识有效性的机制</li><li><em>完整性</em><br>检测消息是否被篡改或伪造的机制</li></ul><p><strong>加密：</strong><br>为了建立加密的安全数据通道，连接双方必须就加密数据的密钥套件和密钥协商一致。TLS采用的是公钥密码系统（也称“非对称密钥加密”），这套系统可以让通信双方不比认识即可商定共享的安全密钥，而且协商过程是通过非加密通道完成的。</p><p style="color:rgb(250,150,150)">PS：<br>1. 对称密钥加密（私钥加密）：对称密钥加密又叫专用密钥加密或共享密钥加密，即发送和接收数据的双方必使用相同的密钥对明文进行加密和解密运算。它的最大优势是加/解密速度快，适合于对大数据量进行加密，但密钥管理困难。<br>A处：明文+私钥=密文 M = Fk(M’)<br>B处： 明文+私钥=密文 M = Fk(M’)<br>2.非对称密钥加密（公钥加密）：它需要使用一对密钥来分别完成加密和解密操作，一个公开发布，即公开密钥，另一个由用户自己秘密保存，即私用密钥。信息发送者用公开密钥去加密，而信息接收者则用私用密钥去解密。公钥机制灵活，但加密和解密速度却比对称密钥加密慢得多。<br>A处：明文+B的公钥=密文<br>B处： 密文+B的私钥=明文<br></p><p><strong>身份验证：</strong><br>身份验证是通过证书链来认证的，这个验证首先需要建立“认证机构信任链”（Chain of Trust and Certificate）。比如公司可以验证每一位员工，员工也有公司签发的独一无二的认证证书。</p><p><strong>完整性检测：</strong><br>除了加密和身份验证，TLS协议还提供了自己的消息分帧机制，使用MAC（Message Authentication Code 消息认证码）签署每一条消息。只要发送TLS记录，就会生成一个MAC值并且附加到该消息中。接收端通过计算和验证这个MAC值来判断消息的完整性和可靠性。</p><h6 id="4-2-TLS握手"><a href="#4-2-TLS握手" class="headerlink" title="4.2 TLS握手"></a>4.2 TLS握手</h6><p>TLS握手协议<br><img src="/2018/07/04/《Web性能权威指南》读书笔记-fourth/TSL-shakehand.png" class="congestion" title="TLS握手协议"></p><ul><li><p>0ms：TLS在可靠的传输层（TCP）之上运行，所以必须首先完成TCP的三次握手。</p></li><li><p>56ms：TCP建立之后，客户端再以纯文本形式发送一些规格说明，比如它所运行的TLS协议的版本，他所支持的加密套件列表，以及它支持或希望使用的另一些TLS选项</p></li><li><p>84ms：服务器取得TLS协议版本以备将来通信使用，从客户端提供的加密套件中选择一个，再附上自己的证书以及自己的公钥，将响应发送回客户端。作为可选项，服务器也可以发送一个请求，要求客户端提供证书以及其他的TLS扩展。</p></li><li><p>112ms：假设两端经过协商确定了共同的版本和加密套件，客户端也把自己的证书提供给了服务器。人后客户端会生成一个新的对称密钥（也就是私钥），用服务器提供的公钥来将该私钥加密，发送给服务器。</p></li><li><p>140ms：服务器用自己的私钥来解密客户端发来的消息，获得客户端的私钥，通过验证消息的MAC检测消息完整性，再返回给客户端一个用刚刚解密获得的私钥加密的“Finished”消息。</p></li><li><p>168ms：客户端用刚刚自己生成的私钥来解密这条消息，验证MAC，如果一切顺利，则建立通信传输数据。</p></li></ul><h6 id="4-2-1-应用层协商"><a href="#4-2-1-应用层协商" class="headerlink" title="4.2.1 应用层协商"></a>4.2.1 应用层协商</h6><p><strong>重要概念</strong></p><ul><li><strong>ALPN：</strong>应用层协商协议，Application Layer Protocol Negotiation，作为TLS扩展，让我们能在TLS握手的同时协商应用协议，从而省掉了HTTP的Upgrade机制所需要的额外往返时间。</li></ul><p>具体过程如下：</p><ul><li><p>client在ClientHello消息中追加一个新的ProtocolNameList字段，包含自己支持的应用协议；</p></li><li><p>server端检查ProtocolNameList字段，并在ServerHello消息中以ProtocolName字段返回选中的协议<br></p><p style="color:rgb(250,150,150)">PS：如果服务器不支持ProtocolNameList中的任何协议，则断开连接</p><br>理论上，网络上的任意两端都可以使用自定义的协议进行通信。为此，需要提前确定使用什么协议，指定端口号（HTTP是80，TLS是443）<br>HTTP协议还专门为协商协议规定了一个Upgrade首部。但是Upgrade需要一次额外的往返时间，且由于许多中间设备的存在，协商结果也不可靠。<p></p></li></ul><h6 id="4-2-2-服务器名称指示（SNI）"><a href="#4-2-2-服务器名称指示（SNI）" class="headerlink" title="4.2.2 服务器名称指示（SNI）"></a>4.2.2 服务器名称指示（SNI）</h6><p><strong>重要概念</strong></p><ul><li><strong>SNI：</strong>Server Name Indication 服务器名称指示，是TLS协议的一个扩展，该扩展允许客户端在握手之初就指明要连接的主机名。Web服务器可以检查SNI主机名，选择适当的证书，继续完成握手。</li></ul><p>网络上可以建立TCP连接的任意两端都可以建立加密TLS信道，客户端只需要知道另一端的IP地址即可建立连接并进行TLS握手。然而每个站点都拥有自己的TLS证书，这就出现了问题</p><p style="color:rgb(250,150,150)">PS：TLS+SNI机制与HTTP中发送Host首部是相同的，只不过后者是客户端要在请求中包含的站点是主机名。总之，都是相同的IP地址服务于不同的域名，而区分不同域名的手段就是SNI或者Host，而且需要注意的是在TLS握手之初https的请求协议还没到，因此是不知道host的，所以需要SNI</p><h6 id="4-3-TLS会话恢复"><a href="#4-3-TLS会话恢复" class="headerlink" title="4.3 TLS会话恢复"></a>4.3 TLS会话恢复</h6><p>完整的TLS握手会带来额外的延迟和计算量，从而给应用程序带来性能损失，为了挽回某些损失，TLS提供了恢复功能，即在多个连接间共享协商后的密钥。</p><h6 id="4-3-1-会话标识符"><a href="#4-3-1-会话标识符" class="headerlink" title="4.3.1 会话标识符"></a>4.3.1 会话标识符</h6><p><strong>重要概念</strong></p><ul><li><strong>会话标识符：</strong>Session Identifiier，这个机制是在SSL2.0中引入的，支持服务器创建32字节的会话标识符，并且在TLS协商期间作为“ServerHello”消息的一部分发送。</li></ul><p>在内部，服务器会为每个客户端保存一个会话ID和协商后的会话参数。客户端也可以保存会话ID信息，并且会在后续会话的“ClientHello”消息中，告诉服务端自己可以重用上次的加密套件和密钥。</p><ul><li>优点：借助会话标识符可以节省一次往返，还可以省掉用于协商共享加密密钥和公钥加密的计算。</li><li>缺点：由于服务器必须为每个客户端都创建和维护一段会话缓存，特别是对于那些每天都要处理几万甚至几百万独立连接的服务器来说，每个打开的TLS连接都要占用内存，因此需要一套会话ID缓存清除策略。</li></ul><h6 id="4-3-1-会话标识符-1"><a href="#4-3-1-会话标识符-1" class="headerlink" title="4.3.1 会话标识符"></a>4.3.1 会话标识符</h6><p><strong>重要概念</strong></p><ul><li><strong>会话记录单：</strong>Session Ticket，该机制是为了解决会话标识符的缓存问题。</li></ul><p>该机制不用服务器保存每个客户端的会话状态。如果客户端表明其支持会话记录单，则服务器可以在完整的TLS握手的最后一次交换中添加一条“新会话记录单（New Session Ticket）”记录，包含只有服务器知道的安全密钥加密过的会话数据。<br>客户端会将这个会话记录单保存起来，然后在后续的会话的ClientHello消息中，将其包含在Session Ticket扩展中。实现TLS的恢复连接。</p><h6 id="4-4-针对TLS的优化建议"><a href="#4-4-针对TLS的优化建议" class="headerlink" title="4.4 针对TLS的优化建议"></a>4.4 针对TLS的优化建议</h6><h6 id="4-4-1-计算成本"><a href="#4-4-1-计算成本" class="headerlink" title="4.4.1 计算成本"></a>4.4.1 计算成本</h6><p>记住一点：公钥加密的算法比私钥加密的代价要大得多</p><h6 id="4-4-2-尽早完成握手"><a href="#4-4-2-尽早完成握手" class="headerlink" title="4.4.2 尽早完成握手"></a>4.4.2 尽早完成握手</h6><p>尽量实现TSL的会话恢复，如果不行，就尽量减少延迟<br>通过把服务器放到离用户更近的地方是一个不错的选择<br>在世界各地的服务器上缓存或者重复部署数据和服务，而不要让所有的用户都通过跨海或跨大陆连接到一个中心的原始服务器，这就是CDN的主要服务内容。<br>虽然CDN常用于在全球优化分发静态资源，但其优点并不止于此。距离客户端更近的服务器还可以缩短TLS会话，因为TCP和TLS握手的对象都是近处的服务器，所以连接的总延迟就会显著减少。相应的，本地代理服务器则可以与原始服务器建立一批长期的安全连接，全权代理请求与相应。</p><h6 id="4-4-3-会话缓存与无状态恢复"><a href="#4-4-3-会话缓存与无状态恢复" class="headerlink" title="4.4.3 会话缓存与无状态恢复"></a>4.4.3 会话缓存与无状态恢复</h6><p>SSL 2.0引入的会话标识符机制是TLS会话缓存的基础，目前已经得到大多数浏览器和客户端的支持。<br>此外，如果客户端和服务器都支持会话记录单，使用会话记录单会解决服务器的缓存问题，更为方便，但是并非所有服务器都支持，所以最好可以同时兼容这两个方案。</p><h6 id="4-4-4-TLS记录大小"><a href="#4-4-4-TLS记录大小" class="headerlink" title="4.4.4 TLS记录大小"></a>4.4.4 TLS记录大小</h6><p>所有通过TLS交付的应用数据都会根据记录协议传输。每条记录的上限为16kb。视选择加密方式不同，每条数据还可能带有20到40字节的首部、MAC及可选的填充信息。如果记录可以封装在一个TCP分组内，则还会给他增加IP和TCP字段，即20字节的IP首部和20字节的TCP首部。结果每条记录大小就变成了60-100字节。由于MTU通常为1500字节，因此分组占比最小的情况下只相当于帧的6%。<br>记录越小分帧浪费越大。但是简单的把每条记录增大到上限（60kb）也不一定好，如果记录要分成多个TCP分组，那么TLS层必须等到TCP分组都到达之后才能揭秘数据。所以TCP机制的一些限制问题就会出现，丢包重发、队首阻塞等等，从而增加延迟。</p><h6 id="4-4-5-TLS压缩"><a href="#4-4-5-TLS压缩" class="headerlink" title="4.4.5 TLS压缩"></a>4.4.5 TLS压缩</h6><p>TLS压缩功能是协议内置的。压缩算法在TLS握手期间商定，在对记录加密之前执行。在实践中最好关闭压缩功能</p><ul><li>2012年公布的“CRIME”攻击会利用TLS压缩恢复加密认证cookie，让攻击者实施会话劫持。</li><li>传输级的TLS压缩不关心内容，可能会压缩已经压缩过的数据（图像、视频等）。</li></ul><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> Reading notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Web性能权威指南》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web性能权威指南》读书笔记---third</title>
      <link href="/2018/06/26/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-third/"/>
      <url>/2018/06/26/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B-third/</url>
      <content type="html"><![CDATA[<blockquote><p>合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。</p><footer><strong>《Web性能权威指南》</strong><cite>——Ilya Grigorik</cite></footer></blockquote><h4 id="第三章-UDP的构成"><a href="#第三章-UDP的构成" class="headerlink" title="第三章 UDP的构成"></a>第三章 UDP的构成</h4><p><strong>核心概念</strong></p><ul><li><p><strong>UDP：</strong>User Datagram Protocol，用户数据报协议，位于OSI参考模型的传输层，位于IP的下层。<i style="color:#d2d2d2;">RFC 768</i>描述了其运作机制，UDP的亮点并不在于他引入了什么特性，而在于他忽略了什么特性。</p></li><li><p><strong>数据报：</strong>一个完整的、独立的数据实体，携带着从源节点到目的地节点的足够信息，对这些节点间的数据交换和传输网络没有任何依赖。</p></li><li><p><strong>DNS：</strong>Domain Name System，域名系统，万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。</p></li></ul><p style="color:rgb(250,150,150)">PS：数据报（datagram）和分组（packet）是两个经常被人混用的词，实际上他们是有区别的：<br>分组可以用来指代任何格式化的数据块，而数据报则通常只用来描述那些通过不可靠的服务传输的分组，既不保证送达，也不发送失败通知。</p><h6 id="3-1-无协议服务"><a href="#3-1-无协议服务" class="headerlink" title="3.1 无协议服务"></a>3.1 无协议服务</h6><p>要理解为什么UDP被人称作“无协议”，必须从TCP何UDP的下一层IP协议说起。<br>IP层的主要任务就是按照地址从源主机向目标主机发送数据报。为此，消息会被封装在一个IP分组内部，其中载明了源地址和目标地址，以及一些其他路由参数。</p><p style="color:rgb(250,150,150)">PS：由于IP层发送的是数据报，则IP层不保证消息可靠的交付，也不发送失败通知，实际上是把底层网络的不可靠性直接暴露给了上一层。如果某个节点因为网络拥塞、负载过高或其他原因而删除了IP分组，那么在必要情况下，IP的上一层协议要负责检测、恢复和重发数据。</p><br>而UDP协议会用自己的分组结构封装用户消息，他只增加了4个字段：源端口、目标端口、分组长度和校验和。<br>当IP分组送达主机目标时，该主机能够拆开UDP分组，根据目标端口找到目标应用程序，然后再把消息发送出去。<br><br><strong>UDP无服务：</strong><br><em> 不保证信息交付：不确认，不重传，无超时。</em> 不保证交付顺序：不设置包顺序，不重排，不会发生队首阻塞。<br><em> 不跟踪连接状态：不必建立连接或重启状态机。</em> 不需要拥塞控制：不内置客户端或网络反馈机制。<br><br><img src="/2018/06/26/《Web性能权威指南》-third/timg.jpeg" class="congestion" title="IPv4首部"><br><br>###### 3.2 UDP与网络地址转换器<br>IPv4地址只有32位长，因而最多只能提供42.9亿个唯一IP地址。1994年，NAT规范作为解决IPv4地址即将耗尽的一个临时性方案出台了。<br><strong>重要概念</strong><br>* <strong>NAT：</strong>Network Address Translation，IP网络地址转换器<br><p style="color:rgb(250,150,150)">PS：这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接</p><h6 id="3-2-1-连接状态超时"><a href="#3-2-1-连接状态超时" class="headerlink" title="3.2.1 连接状态超时"></a>3.2.1 连接状态超时</h6><p>NAT转换的问题（至少对于UDP而言）在于必须维护一份精确的路由表才能保证数据转发。NAT设备依赖连接状态，而UDP没有连接状态。这种根本上的错配是很多UDP数据报传输问题的总根源</p><h6 id="3-2-2-NAT穿透"><a href="#3-2-2-NAT穿透" class="headerlink" title="3.2.2 NAT穿透"></a>3.2.2 NAT穿透</h6><p><strong>重要概念</strong></p><ul><li><strong>NAT穿透：</strong>NAT带来的一个问题就是内部客户端不知道外网的IP地址，只知道内网IP的地址。NAT负责重写每个UDP分组中的源端口、地址，以及IP分组中的源IP地址。如果客户端以内网地址进行通信，那么连接必然是失败的。</li></ul><p>为了解决UDP与NAT的这种不搭配，人们发明了很多穿透技术（TURN、STUN、ICE）</p><h6 id="3-2-3-STUN、TURN、ICE"><a href="#3-2-3-STUN、TURN、ICE" class="headerlink" title="3.2.3 STUN、TURN、ICE"></a>3.2.3 STUN、TURN、ICE</h6><p> <strong>STUN：</strong>Session Traversal Utilities for NAT,是一个协议（RFC 5389），他可以让应用程序发现网络中的地址转换器，发现之后进一步取得为当前连接分配的外网IP地址和端口。为此，这个协议需要一个已知的第三方STUN服务器支持，该服务器必须假设在公网上。</p><p>假设STUN服务器的IP地址已知，客户端首先会向STUN服务器发送一个绑定请求。然后，STUN服务器返回一个响应，其中包含在外网中代表客户端的IP地址和端口号。</p><ul><li>客户端可以获得外网的IP和端口，并利用这些信息与对端通信。</li><li>发送到STUN服务器的出站绑定请求将在通信要经过的NAT中建立路由条目，使得到达该IP和端口的入站分组可以找到内网中的应用程序</li><li>STUN协议定义了一个简单的keep-alive探测机制，可以保证NAT路由条目不超时</li></ul><p>有了这个机制，两台主机端需要通过UDP通信时，它首先都会向各自的服务器发送绑定请求，然后分别使用响应中的外网IP地址和端口号交换数据。<br> <strong>TURN：</strong>Traversal Using Relays around NAT，TURN可以在最坏的情况下跳过UDP而切换到TCP（RFC 5766）<br>这个协议依赖于外网中继设备在两端间传递数据。</p><ul><li>两端都要向同一台TURN服务器发送分配请求来建立连接，然后再进行权限协商。</li><li><p>协商完毕，两端都把数据发送到TURN服务器，再用TURN服务器转发，从而实现通讯。<br><strong>ICE：</strong>能直连就直连，必要时STUN协商，实在不行就使用TURN</p><h6 id="3-3-针对UDP的优化建议"><a href="#3-3-针对UDP的优化建议" class="headerlink" title="3.3 针对UDP的优化建议"></a>3.3 针对UDP的优化建议</h6><p>UDP的特色在于他所省略的那些功能：连接状态、握手、重发、重组、重排、拥塞控制、拥塞预防、流量控制、甚至是可选的错误检测</p></li><li>应用程序必须容忍各种因特网路径条件</li><li>应用程序应该控制传输速度</li><li>应用程序应该对所有的流量进行拥塞控制</li><li>应用程序应该使用与TCP相近的带宽</li><li>应用程序应该准备基于丢包的重发计数器</li><li>应用程序应该不发送大于路劲MTU的数据报</li><li>应用程序应该处理数据报丢失、重复和重排</li><li>应用程序应该足够稳定以支持2分钟以上的交付延迟</li><li>应用程序应该支持IPv4 UDP校验和，必须支持IPv6校验和</li><li>应用程序可以在需要时使用keep-alive（最小间隔15秒）</li></ul><p>可以了解一下WebRTC</p><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> Reading notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Web性能权威指南》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web性能权威指南》读书笔记---second</title>
      <link href="/2018/06/13/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-second/"/>
      <url>/2018/06/13/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-second/</url>
      <content type="html"><![CDATA[<blockquote><p>合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。</p><footer><strong>《Web性能权威指南》</strong><cite>——Ilya Grigorik</cite></footer></blockquote><h4 id="第二章-TCP的构成"><a href="#第二章-TCP的构成" class="headerlink" title="第二章 TCP的构成"></a>第二章 TCP的构成</h4><p>首先先说一下OSI七层模型：<br>开放系统互连参考模型 (Open System Interconnect 简称OSI）是国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合制定的开放系统互连参考模型，为开放式互连信息系统提供了一种功能结构的框架。它从低到高分别是：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p><ul><li><p><strong>物理层：</strong>物理层并不是物理媒体本身，它只是开放系统中利用物理媒体实现物理连接的功能描述和执行连接的规程。物理层提供用于建立、保持和断开物理连接的机械的、电气的、功能的和过程的条件。简而言之，物理层提供有关同步和全双工比特流在物理媒体上的传输手段，其典型的协议有RS 232C、RS 449/422/423、V.24和X.21、X.21bis等。</p></li><li><p><strong>数据链路层：</strong>数据链路可以粗略地理解为<em><strong>数据通道</strong></em>。物理层要为终端设备间的数据通信提供传输介质及其连接。介质是长期的，连接是有生存期的。在连接生存期内，收发两端可以进行不等的一次或多次数据通信。每次通信都要经过建立通信联络和拆除通信联络两个过程。<em><strong>这种建立起来的数据收发关系就叫做数据链路。</strong></em>而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错，为了弥补物理层上的不足，为上层提供无差错的数据传输，就要能对数据进行检错和纠错。数据链路的建立，拆除，对数据的检错，纠错是数据链路层的基本任务。</p></li><li><p><strong>网络层：</strong>网络层的产生也是网络发展的结果。在联机系统和线路交换的环境中，网络层的功能没有太大意义。当数据终端增多时。它们之间有中继设备相连，此时会出现一台终端要求不只是与惟一的一台而是能和多台终端通信的情况，这就产生了把任意两台数据终端设备的数据链接起来的问题，也就是路由或者叫寻径。另外，当一条物理信道建立之后，被一对用户使用，往往有许多空闲时间被浪费掉。人们自然会希望让多对用户共用一条链路，为解决这一问题就出现了逻辑信道技术和虚拟电路技术。<br>我们常见的是路由器、网关等</p></li><li><p><strong>传输层：</strong>提供建立、维护和拆除传送连接的功能；选择网络层提供最合适的服务；在系统之间提供可靠的透明的数据传送，提供端到端的错误恢复和流量控制。端开放系统之间的数据传送控制层。主要功能是端开放系统之间数据的收妥确认。同时，还用于弥补各种通信网路的质量差异，对经过下三层之后仍然存在的传输差错进行恢复，进一步提高可靠性。<br>很多时候我们会发现QQ聊天的速度很快，但是我们上网速度就很慢，这就是因为QQ使用UDP协议，没有纠错功能，而网络的传输使用的是TCP协议，它的纠错功能就会导致传输速度变慢。</p></li><li><p><strong>会话层：</strong>提供两进程之间建立、维护和结束会话连接的功能；提供交互会话的管理功能，如三种数据流方向的控制，即一路交互、两路交替和两路同时会话模式 。会话层是会话单位的控制层，其主要功能是按照在应用进程之间约定的原则，按照正确的顺序收、发数据，进行各种形态的对话。会话层规定了会话服务用户间会话连接的建立和拆除规程以及数据传送规程。</p></li><li><p><strong>表示层：</strong>代表应用进程协商数据表示；完成数据转换、格式化和文本压缩。表示层是数据表示形式的控制层，其主要功能是把应用层提供的信息变换为能够共同理解的形式，提供字符代码、数据格式、控制信息格式、加密等的统一表示。表示层的作用之一是为异种机通信提供一种公共语言，以便能进行互操作。</p></li><li><p><strong>应用层：</strong>提供OSI用户服务，例如事务处理程序、文件传送协议和网络管理等。</p></li></ul><p>七层模型是很抽象的一个概念。一般情况下，<strong><em>物理层，数据链路层，网络层对应的是一个设备，</em></strong>这个设备在某一层就有某种功能，<strong><em>而传输层，会话层，表示层对应的是协议，</em></strong>而应用层就是使用什么样的软件。<br><img src="/2018/06/13/《Web性能权威指南》读书笔记-second/osi.jpg" class="osi" title="OSI七层模型"></p><p><strong>核心概念</strong></p><ul><li><p><strong>TCP：</strong>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。负责在不可靠的传输信道上提供可靠的抽象层TCP和UDP位于OSI七层模型的传输层。</p></li><li><p><strong>IP：</strong>IP即Internet Protocol（因特网协议）负责联网主机间的路由选择和寻址。位于OSI七层模型的网络层</p></li><li><p><strong>RFC：</strong>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。</p><p style="color:rgb(250,150,150)">一个RFC文件在成为官方标准前一般至少要经历4个阶段【RFC2026】：因特网草案、建议标准、草案标准、因特网标准。</p><p></p></li></ul><p>TCP负责在不可靠的传输通道上提供可靠的抽象层，向应用层隐藏了大多数网络通信的复杂细节，比如丢包重发、按序发送、拥塞控制及避免、数据完整等等。采用TCP数据流可以确保所有的发送字节都能被完整的接收到，而且到达客户端的顺序也一样。</p><p style="color:rgb(250,150,150)">IPv4：TCP/IP协议的第四个版本</p><p style="color:rgb(250,150,150)">IPv6：在1994年时，工作组开始着手制定Internet Protocol next generation(IPng)需要一个版本号时，v5已经被分配给了另一个实验性协议（Internet Stream Protocol）ST,但是ST一直没有什么进展，因此TCP/IP的下一个版本就成了IPv6</p><h6 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h6><img src="/2018/06/13/《Web性能权威指南》读书笔记-second/TCP.png" class="osi" title="OSI七层模型"><ul><li><strong>SYN</strong><br>客户端选择一个随机序列号x，并发送一个SYN分组，其中还可能包括其他TCP标志和选项。</li><li><strong>SYN ACK</strong><br>服务器给x加1，并且选择一个自己的随机序列号y，追加自己的标志和选项，然后返回响应。</li><li><strong>ACK</strong><br>客户端给x和y加1并发送握手时期的最后一个ACK分组</li></ul><p>三次握手之后，客户端和服务器之间就可以开始通信了。客户端可以在发送ACK分组之后立即发送数据，而服务器必须等到接收到ACK分组之后才能发送数据。这个过程适用于所有的TCP连接，因此对所有使用TCP的应用的性能有巨大的影响，因为每次传输数据之前都要经历一次完整的往返。这也决定了提高TCP的应用性能的关键在于想办法重用连接。</p><p style="color:rgb(250,150,150)">PS：在三次握手的过程中，连接的带宽对时间没有影响，延迟完全取决于客户端和服务端之间的往返时间，这其中主要是客户端到服务器的传输时间</p><h6 id="2-2-拥塞预防和控制"><a href="#2-2-拥塞预防和控制" class="headerlink" title="2.2 拥塞预防和控制"></a>2.2 拥塞预防和控制</h6><h6 id="2-2-1流量控制"><a href="#2-2-1流量控制" class="headerlink" title="2.2.1流量控制"></a>2.2.1流量控制</h6><p><strong>流量控制：</strong>流量控制是一种预防发送端过多的向接收端发送数据的机制。否则接收端可能因为忙碌、负载重或者缓冲区既定而无法处理。为实现流量的控制，TCP连接的每一方都要通告自己的接受窗口（rwnd）的大小，其中包含能够保存数据的缓冲区空间大小的信息。</p><p><strong>窗口缩放：</strong>最初的TCP规范分配给通告窗口的字段是16位的，这相当于设定了发送端和接收端的窗口的最大值（2的16次方即65535字节）。为了解决这个问题，RFC1323提供了<strong><em>“TCP窗口缩放(TCP Window Scaling)”</em></strong>选项可以把接受窗口的大小提高到1G字节。今天，TCP窗口缩放机制在所有主要平台上都是默认开启的。</p><h6 id="2-2-2慢启动"><a href="#2-2-2慢启动" class="headerlink" title="2.2.2慢启动"></a>2.2.2慢启动</h6><p>流量控制确实可以防止发送端向接收端过多的发送数据，但是却没有机制预防任何一端向潜在网络过多的发送数据。发送端和接收端在连接建立之初，谁也不知道可用带宽是多少，因此需要一个估算机制，然后还需要根据网络中不断变化的条件而动态改变速度。</p><p><i style="color:#d2d2d2;">一个例子：可以想象你在家里观看一个大型的流视频。视频服务器会根据你的下行连接提供最高品质的信息。而此时，你的身边有人打开了一个大型的下载包，可供视屏流使用的下行带宽瞬间减小，视频服务器必须调整他的发送速度。否则，如果继续保持同样的速度，那么数据很快就会堆积在某个中间的网关，最终导致分组被删除，从而降低网络传输效率。</i></p><p><strong>拥塞窗口大小（cwnd）：</strong>发送端对从客户端接受确认（ACK）之前可以发送数据量的限制。<br><ul style="color:rgb(250,150,150)"><br>    <li>rwnd主要是用来解决接收端过载的问题，而cwnd则是用来解决网络过载问题的。</li><br>    <li>同时cwnd只是接收端独自维护的一个私有变量，而接收端和发送端之间可以传输的最大数据量取决于cwnd和rwnd的最小值。</li><br></ul></p><p>在经历了三次握手之后,客户端和服务器就可以进行信息交流了，首先接收端通过TCP连接初始化一个新的拥塞窗口（cwnd）变量，将其设置为一个系统设定的保守值（在linux中就是initcwnd）<br>慢启动的解决方案，即在连接建立后缓慢的增大cwnd的大小，最初cwnd的值只有1个TCP段，然后成指数增长，这等于是说，只要是运行在TCP上的应用层协议，都不可能一下就完全利用连接的最大带宽</p><img src="/2018/06/13/《Web性能权威指南》读书笔记-second/slow-start.png" class="osi" title="OSI七层模型"><p><strong>计算公式一：cwnd大小达到N所需的时间</strong><br>一个例子：</p><ul><li>N=64kb；</li><li>初始的拥塞窗口：4段；</li><li>往返时间是56ms</li><li>64kb=63535字节 一段拥塞窗口=1460字节<br>65535字节/1460字节≈45段<br>4<em>2^x&gt;=45<br>得出 x&gt;4<br>4</em>56=224ms</li><li>所以得出要达到客户端与服务端之间64kb每次的吞吐量，需要四次往返，这是几百毫秒的延迟！并且只跟初始cwnd的大小以及往返时间有关系</li></ul><p style="color:rgb(250,150,150)">PS：慢启动重启，除了调节新连接的传输速度，TCP还实现了SSR(Slow-Start Restart,慢启动重启)机制。这种机制会在连接空闲一定时间后重置连接的拥塞窗口。道理很简单，在连接空闲的同时，网络状况也可能发生了变化，为了避免拥塞，理应将拥塞窗口重置会安全的默认值</p><h6 id="2-2-3-拥塞预防"><a href="#2-2-3-拥塞预防" class="headerlink" title="2.2.3 拥塞预防"></a>2.2.3 拥塞预防</h6><p>TCP调节性能主要依赖于丢包反馈机制。<br>慢启动以保守的窗口初始化连接，随后的每次往返都会成倍的提高传输的数据量，直到超过接收端的流量控制窗口，即系统配置的拥塞阀值(ssthresh)窗口，或者有分组丢失为止，此时拥塞预防算法介入。</p><img src="/2018/06/13/《Web性能权威指南》读书笔记-second/congestion.png" class="congestion" title="拥塞预防和拥塞控制"><p>重置拥塞窗口后，拥塞预防按照自己的算法来增大窗口以尽量避免丢包。某个时刻可能又会有包丢失，于是这个过程再重头开始。</p><h6 id="2-3-带宽延迟积"><a href="#2-3-带宽延迟积" class="headerlink" title="2.3 带宽延迟积"></a>2.3 带宽延迟积</h6><p><strong>重要概念</strong></p><ul><li>带宽延迟积：BDP(Bandwidth-delay product) 数据链路容量与其端到端延迟的乘积。这个结果就是任意时刻在途未确认状态的最大数据量。</li></ul><p><em>如何充分利用带宽</em></p><ul><li>增大rwnd(流量控制窗口)和cwnd(拥塞控制窗口)的最小值</li><li>或者减少端到端的延迟<br>首先假设cwnd和rwnd的最小值是16KB<br>端与端之间的往返时间是100ms<br>16KB=131072 bit<br>131072bit/0.1s=1310720bit/s=1.31M bit/s<br>所以不管发送端还是接收端的实际带宽是多大，这个TCP连接的传输速率只取决于最小窗口值，以及往返时间</li></ul><h6 id="2-4-队首阻塞"><a href="#2-4-队首阻塞" class="headerlink" title="2.4 队首阻塞"></a>2.4 队首阻塞</h6><p>TCP在不可靠的信道上实现了可靠的网络传输。基本的分组错误检测与纠正、按序交付、丢包重发、以及保证网络最高效率的流量控制、拥塞预防与控制机制<br><strong>重要概念</strong></p><ul><li><em><strong>队首阻塞：</strong></em>每个TCP分组都会带着一个唯一的序列号被发出，而所有的分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收端，那么后续的分组必须保存在接收端的TCP缓冲区，等待丢失的分组重新发送并到达接收端。这种效应被称为队首阻塞。</li></ul><p>队首阻塞造成的延迟可以让我们的应用程序不用关心分组重排和重组，从而让代码保持简洁。但是分组到达时间会出现无法预测的延迟变化。这个时间变化通常被成为<i style="color:#d2d2d2;">抖动</i>，也是影响应用程序性能的一个主要因素。<br>无需按序交付或者能够处理分组丢失的应用程序，以及对延迟或抖动要求很高的应用程序最好选择UDP协议。</p><h6 id="2-5-针对TCP的优化建议"><a href="#2-5-针对TCP的优化建议" class="headerlink" title="2.5 针对TCP的优化建议"></a>2.5 针对TCP的优化建议</h6><p>TCP是一个自适应的、对所有网络节点一视同仁的、最大限度利用底层网络的协议。因此，优化TCP的最佳途径就是调整他感知当前网络状况的方式，根据它之上或之下的抽象层类型和需求来改变他们的行为。<br>不同的应用程序需求间的复杂关系，以及每个TCP算法中的大量因素，使得TCP调优成为学术和商业上的无底洞。<br>尽管每个算法和反馈机制的具体细节可能会继续发展，但核心原理以及他们的影响是不会变的：</p><ul><li>TCP三次握手增加了整整一次往返时间；</li><li>TCP慢启动将会应用到每一个新连接；</li><li>TCP流量以及拥塞控制会影响所有连接的吞吐量；</li><li>TCP的吞吐量由当前拥塞窗口的大小控制。</li></ul><h6 id="2-5-1-服务器配置调优"><a href="#2-5-1-服务器配置调优" class="headerlink" title="2.5.1 服务器配置调优"></a>2.5.1 服务器配置调优</h6><p>首先应该进行的操作就是升级服务器内核<br>TCP的最佳实践以及影响其性能的底层算法一直在与时俱进，而且大多数变化都只在最新内核中才有实现。<br>有了最新的内核之后：</p><ul><li>增大TCP的初始拥塞窗口的大小</li><li>禁用慢启动重启</li><li>启用窗口缩放</li><li>TCP快速打开</li></ul><h6 id="2-5-2-应用程序行为调优"><a href="#2-5-2-应用程序行为调优" class="headerlink" title="2.5.2 应用程序行为调优"></a>2.5.2 应用程序行为调优</h6><ul><li>再快也快不过什么都不发，减少冗余数据的发送</li><li>我们不能让数据传输的更快，但是可以让他们的传输的距离更短</li><li>重用TCP是提升性能的关键</li></ul><h6 id="2-5-3-总结"><a href="#2-5-3-总结" class="headerlink" title="2.5.3 总结"></a>2.5.3 总结</h6><ul><li>把服务器内核升级到最新版本；</li><li>确保cwnd的大小为10；</li><li>禁用空闲后的慢启动；</li><li>确保启动窗口缩放；</li><li>减少传输冗余数据；</li><li>压缩要传输的数据；</li><li>把服务器放到离用户更近的地方；</li><li>尽最大的可能重用已建立的TCP连接。</li></ul><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> Reading notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Web性能权威指南》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《Web性能权威指南》读书笔记---first</title>
      <link href="/2018/06/13/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-first/"/>
      <url>/2018/06/13/%E3%80%8AWeb%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-first/</url>
      <content type="html"><![CDATA[<blockquote><p>合格的开发者知道怎么做，而优秀的开发者知道为什么那么做。</p><footer><strong>《Web性能权威指南》</strong><cite>——Ilya Grigorik</cite></footer></blockquote><h4 id="第一章-延迟与带宽"><a href="#第一章-延迟与带宽" class="headerlink" title="第一章 延迟与带宽"></a>第一章 延迟与带宽</h4><h6 id="1-1-速度是关键"><a href="#1-1-速度是关键" class="headerlink" title="1.1 速度是关键"></a>1.1 速度是关键</h6><p><strong>WPO</strong>:Web Performance Optimizition Web性能优化<br>很多在线公司的业绩已经证明：</p><ul><li>网站越快，用户黏性越高</li><li>网站越快，用户忠诚度更高</li><li>网站越快，用户转化率越高</li></ul><p>简言之，网站的速度决定了网站的竞争力<br><strong>核心概念</strong></p><ul><li>延迟：分组从信息源发送到目的地所需的时间</li><li>带宽：逻辑或物理通信路径最大的吞吐量</li></ul><h6 id="1-2延迟的构成"><a href="#1-2延迟的构成" class="headerlink" title="1.2延迟的构成"></a>1.2延迟的构成</h6><ul><li>传播延迟：消息或分组从发送端到接收端需要的时间，是信号传播距离和速度的函数</li><li>传输延迟：把消息或分组中的所有比特转移到链路中需要的时间，是消息长度和链路速率的函数<p style="color:rgb(250,150,150)">PS: 比特（BIT，binary system），计算机专业术语，是信息量单位，是由英文BIT音译而来。同时也是二进制数字中的位，信息量的度量单位，为信息量的最小单位。即信号的信息量</p><p style="color:rgb(250,150,150)">链路，有线通信时，链路指两个节点之间的物理线路，如电缆或光纤。无线电通信时，链路指基站和终端之间传播电磁波的路径空间。水声通信时链路指换能器和水听器之间的传播声波的路径空间。</p></li><li>处理延迟：处理信息或分组首部、检查错误及确定分组目标所需要的时间</li><li>排队延迟：分组到达路由器时排队等待处理的时间</li></ul><h6 id="1-3光速与传播延迟"><a href="#1-3光速与传播延迟" class="headerlink" title="1.3光速与传播延迟"></a>1.3光速与传播延迟</h6><p>传播速度是不会快于光速的。在网络中的信息或者分组是通过铜线、光纤等介质传播的，这些介质会导致传播速度变慢。<br>光速与分组在介质中的传播速度之比叫做介质的折射率，这个值越大，光在该介质的传播速度越慢。通常在1.4-1.6不等。<br><strong>重要概念</strong><br>CDN：Content Delivery Network 内容分发网络，服务器的用途有很多，但是最重要的就是通过把内容部署在全球各地，让用户从最近的服务器加载内容，大幅度降低传播分组的时间。<strong>把数据托管到CDN能够显著的提高性能。</strong></p><h6 id="1-4延迟的最后一公里"><a href="#1-4延迟的最后一公里" class="headerlink" title="1.4延迟的最后一公里"></a>1.4延迟的最后一公里</h6><p>为了让你的设备接入互联网，本地ISP需要在附近安装多个路由器手机信号，然后再将信号转发到本地的路由节点。连接类型、路由技术和部署方式，每个ISP都不尽相同，分组传输中的前几跳往往要花费数十毫秒时间才能到达ISP的主路由器。</p><p style="color:rgb(250,150,150)">PS: ISP(Internet Service Provider)，互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务、和增值业务的电信运营商。</p><h6 id="1-5网络核心的带宽"><a href="#1-5网络核心的带宽" class="headerlink" title="1.5网络核心的带宽"></a>1.5网络核心的带宽</h6><p><strong>光纤</strong>是一根光导管，专门用来从一端向另一端传输光信号。<br><strong>金属线</strong>则用于传输电信号，但是信号损失，电磁干扰较大，同时维护成本较高<br>这两种线路我们的数据分组都有可能经过，但是一般长距离的分组传输都是通过光纤完成的。<br>一条光纤连接的总带宽等于每个信道的数据传输速率乘以可复用的信道数</p><h6 id="1-6网络边缘的带宽"><a href="#1-6网络边缘的带宽" class="headerlink" title="1.6网络边缘的带宽"></a>1.6网络边缘的带宽</h6><p>构成因特网核心数据路径的骨干或者光纤连接，每秒能够移动数百太比特的信息，然而，网络边缘的容量就小得多，而且很大程度上取决于部署技术，比如拨号连接、DSL、电缆、各种无线技术、光纤到户，甚至与局域网路由器的性能也有关系。</p><p style="color:rgb(250,150,150)">PS: 网络边缘：引文单词可以是access layer, 或者network edge.与因特网相连的计算机和其他设备位于英特网的边缘，故而被称为网络边缘，又称端系统。</p><h6 id="1-7目标：高带宽和低延迟"><a href="#1-7目标：高带宽和低延迟" class="headerlink" title="1.7目标：高带宽和低延迟"></a>1.7目标：高带宽和低延迟</h6><p>对于光纤等传输介质来说，是有物理性能的上限的，但是可以在光纤链路中部署更多的管线、在拥塞的路由之间铺设更多的线路，甚至改善WDM技术，以便让现有链路传输更多的数据。但是物理技术并不是没有止境的，但是只要企业的经济条件允许，就算技术停滞不前，还是可以通过铺设更多的光缆来提高带宽。<br>但是大多数网站性能的瓶颈都是延迟而不是带宽</p><p style="color:rgb(250,150,150)">PS: WDM：Wavelength Division Multiplexing 波分复用技术，光线可以同时传播很多不同波长的光，因而具有明显的带宽优势</p><img src="http://p9zhc8gz7.bkt.clouddn.com/photo1.jpg"><p style="text-align:center;font-size:28px ;font-family: 'Hannotate SC','Helvetica Neue',Helvetica,Arial,sans-serif;">The End</p>]]></content>
      
      <categories>
          
          <category> Reading notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 《Web性能权威指南》读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MarkDown语法总结</title>
      <link href="/2018/06/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/06/11/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="这是我常用的MarkDown语法"><a href="#这是我常用的MarkDown语法" class="headerlink" title=" 这是我常用的MarkDown语法"></a> 这是我常用的MarkDown语法</h2><h4 id="1-斜体字与加粗"><a href="#1-斜体字与加粗" class="headerlink" title="1.斜体字与加粗"></a>1.斜体字与加粗</h4><h6 id="1-1-斜体字"><a href="#1-1-斜体字" class="headerlink" title="1.1 斜体字"></a>1.1 斜体字</h6><p>  语法：* *<br>  代码: </p><pre><code>*一支穿云箭*</code></pre><p>演示效果：<em>一支穿云箭</em></p><h6 id="1-2-加粗字"><a href="#1-2-加粗字" class="headerlink" title="1.2 加粗字"></a>1.2 加粗字</h6><p>  语法：** **<br>  代码: </p><pre><code>  **千军万马来相见**</code></pre><p>演示效果：<strong>千军万马来相见</strong></p><h4 id="2-删除线"><a href="#2-删除线" class="headerlink" title="2.删除线"></a>2.删除线</h4><p> 语法：~~ ~~<br> 代码: </p><pre><code> ~~问你苦不苦？~~</code></pre><p>演示效果：<del>问你苦不苦？</del></p><h4 id="3-代码块"><a href="#3-代码块" class="headerlink" title="3.代码块"></a>3.代码块</h4><p>  语法：``` ```<br>  代码:  </p><pre><code>``` html&lt;div class=&quot;xixi&quot; id=&quot;haha&quot;&gt;&lt;p&gt;我什么都不知道啊&lt;/p&gt;&lt;/div&gt;&lt;p&gt;你猜我知不知道&lt;/p&gt;```</code></pre><p>  演示效果：</p><pre><code class="html">&lt;div class=&quot;xixi&quot; id=&quot;haha&quot;&gt;&lt;p&gt;我什么都不知道啊&lt;/p&gt;&lt;/div&gt;&lt;p&gt;你猜我知不知道&lt;/p&gt;</code></pre>  <p style="color:rgb(250,150,150)">PS:加在```后的是语言类型，如：javascript、html、css等</p><h4 id="4-链接"><a href="#4-链接" class="headerlink" title="4.链接"></a>4.链接</h4><h6 id="4-1地址链接"><a href="#4-1地址链接" class="headerlink" title="4.1地址链接"></a>4.1地址链接</h6><p>语法：[title](链接地址)<br>代码：</p><pre><code>[百度一下](http://www.taobao.com)</code></pre><p>演示效果：<a href="http://www.taobao.com" target="_blank" rel="noopener">百度一下</a></p><h6 id="4-12邮箱链接"><a href="#4-12邮箱链接" class="headerlink" title="4.12邮箱链接"></a>4.12邮箱链接</h6><p>语法：&lt;邮箱地址&gt;<br>代码：</p><pre><code>&lt;738481015@qq.com&gt;</code></pre><p>演示效果：<a href="mailto:&#55;&#51;&#56;&#52;&#56;&#49;&#48;&#x31;&#53;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#55;&#51;&#56;&#52;&#56;&#49;&#48;&#x31;&#53;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;</a></p><h4 id="5-图片"><a href="#5-图片" class="headerlink" title="5.图片"></a>5.图片</h4><h6 id="5-1插入普通图片"><a href="#5-1插入普通图片" class="headerlink" title="5.1插入普通图片"></a>5.1插入普通图片</h6><p>语法：![图片alt](图片地址)<br>代码：</p><pre><code>![测试一下图片](./bg1.jp代码)</code></pre><p>演示效果：<img src="/2018/06/11/我的第一篇博客/bg1.jpeg" alt="测试一下图片"></p><h6 id="5-2插入带链接的图片"><a href="#5-2插入带链接的图片" class="headerlink" title="5.2插入带链接的图片"></a>5.2插入带链接的图片</h6><p>语法：[![图片alt](图片地址)](链接地址)<br>代码：</p><pre><code>[![测试一下图片](./bg1.jp代码)](http://www.baidu.com)</code></pre><p>演示效果：<a href="http://www.baidu.com" target="_blank" rel="noopener"><img src="/2018/06/11/我的第一篇博客/bg1.jpeg" alt="测试一下图片"></a></p><h4 id="6-列表"><a href="#6-列表" class="headerlink" title="6.列表"></a>6.列表</h4><h6 id="6-1有序列表"><a href="#6-1有序列表" class="headerlink" title="6.1有序列表"></a>6.1有序列表</h6><p>语法：1. 2. 3.<br>代码：</p><pre><code>1. 嘻嘻嘻2. 哈哈哈3. 呵呵呵</code></pre><p>演示效果：</p><ol><li>嘻嘻嘻</li><li>哈哈哈</li><li>呵呵呵</li></ol><p style="color:rgb(250,150,150)">PS：.后面需要加一个空格</p><h6 id="6-2无序列表"><a href="#6-2无序列表" class="headerlink" title="6.2无序列表"></a>6.2无序列表</h6><p>语法：*<br>代码：</p><pre><code>* 银鞍照白马* 飒沓如流星</code></pre><p>演示效果：</p><ul><li>银鞍照白马</li><li>飒沓如流星</li></ul><h4 id="7-引用"><a href="#7-引用" class="headerlink" title="7.引用"></a>7.引用</h4><h6 id="7-1单行引用"><a href="#7-1单行引用" class="headerlink" title="7.1单行引用"></a>7.1单行引用</h6><p>语法：&gt;<br>代码：</p><pre><code>&gt; 十步杀一人，千里不留行</code></pre><p>演示效果：</p><blockquote><p>十步杀一人，千里不留行</p></blockquote><h6 id="7-2多行引用"><a href="#7-2多行引用" class="headerlink" title="7.2多行引用"></a>7.2多行引用</h6><p>语法：&gt;<br>代码：</p><pre><code>&gt; 十步杀一人，千里不留行&gt; 事了拂衣去，深藏功与名</code></pre><p>演示效果：</p><blockquote><p>十步杀一人，千里不留行<br>事了拂衣去，深藏功与名</p></blockquote><h6 id="7-3多行嵌套"><a href="#7-3多行嵌套" class="headerlink" title="7.3多行嵌套"></a>7.3多行嵌套</h6><p>语法：&gt;<br>代码：</p><pre><code>&gt; 云想衣裳花想容，春风拂槛露华浓&gt;&gt; 若非群玉山头见，会向瑶台月下逢&gt;&gt;&gt;一枝红艳露凝香，云雨巫山枉断肠</code></pre><p>演示效果：</p><blockquote><p>云想衣裳花想容，春风拂槛露华浓</p><blockquote><p>若非群玉山头见，会向瑶台月下逢</p><blockquote><p>一枝红艳露凝香，云雨巫山枉断肠</p></blockquote></blockquote></blockquote><p><hr></p><h3 id="hexo标签插件"><a href="#hexo标签插件" class="headerlink" title="hexo标签插件"></a>hexo标签插件</h3><h4 id="1-引用块"><a href="#1-引用块" class="headerlink" title="1.引用块"></a>1.引用块</h4><pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}content{% endblockquote %}</code></pre><h6 id="1-1普通引用快"><a href="#1-1普通引用快" class="headerlink" title="1.1普通引用快"></a>1.1普通引用快</h6><p>代码：</p><pre><code>{% blockquote %}春江潮水连海平，海上明月共潮生。滟滟随波千万里，何处春江无月明。{% endblockquote %}</code></pre><p>演示效果：<br><blockquote><p>春江潮水连海平，海上明月共潮生。<br>滟滟随波千万里，何处春江无月明。</p></blockquote></p><h6 id="1-2引用书籍的内容"><a href="#1-2引用书籍的内容" class="headerlink" title="1.2引用书籍的内容"></a>1.2引用书籍的内容</h6><p>代码：</p><pre><code>{% blockquote 《Do not go gentle into that good night》, ——Dylan Thomas %}Do not go gentle into that good night,Old age should burn and rave at close of day;Rage, rage against the dying of the light.{% endblockquote %}</code></pre><p>演示效果：<br><blockquote><p>Do not go gentle into that good night,<br>Old age should burn and rave at close of day;<br>Rage, rage against the dying of the light.</p><footer><strong>《Do not go gentle into that good night》</strong><cite>——Dylan Thomas</cite></footer></blockquote></p><h6 id="1-3引用网址的内容"><a href="#1-3引用网址的内容" class="headerlink" title="1.3引用网址的内容"></a>1.3引用网址的内容</h6><p>代码：</p><pre><code>{% blockquote @Synewl http://synewl.coding.me/ %}你以为完事啦？{% endblockquote %}</code></pre><p>演示效果：<br><blockquote><p>你以为完事啦？</p><footer><strong>@Synewl——</strong><cite><a href="http://synewl.coding.me/" target="_blank" rel="noopener">synewl.coding.me</a></cite></footer></blockquote></p><h6 id="1-4引用网页上的文章"><a href="#1-4引用网页上的文章" class="headerlink" title="1.4引用网页上的文章"></a>1.4引用网页上的文章</h6><p>代码：</p><pre><code>{% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %}Every interaction is both precious and an opportunity to delight.{% endblockquote %}</code></pre><p>展示效果：<br><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="noopener">Welcome to Island Marketing</a></cite></footer></blockquote></p><h4 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h4><pre><code>{% codeblock [title] [lang:language] [url] [link text] %}code snippet{% endcodeblock %}</code></pre><h6 id="2-1普通代码块"><a href="#2-1普通代码块" class="headerlink" title="2.1普通代码块"></a>2.1普通代码块</h6><p>代码：</p><pre><code>{% codeblock %}console.log('你该不会是个傻子吧？');{% endcodeblock %}</code></pre><p>展示效果：<br><pre><code>console.log(&#39;你该不会是个傻子吧？&#39;);</code></pre></p><h6 id="2-2-指定语言的代码块"><a href="#2-2-指定语言的代码块" class="headerlink" title="2.2 指定语言的代码块"></a>2.2 指定语言的代码块</h6><p>代码：</p><pre><code>{% codeblock lang:javascript %}let a={}let b=[]{% endcodeblock %}</code></pre><p>演示效果：<br><pre><code>let a={}let b=[]</code></pre></p><h4 id="3-加入图片"><a href="#3-加入图片" class="headerlink" title="3. 加入图片"></a>3. 加入图片</h4><p>代码：</p><pre><code>{% img testImg /2018/06/11/我的第一篇博客/bg1.jpeg 1000 200 我只是看下大不大%}</code></pre><p>演示效果：<br><img src="/2018/06/11/我的第一篇博客/bg1.jpeg" class="testImg" width="1000" height="200" title="我只是看下大不大"></p><hr><h4 id="以上就是我写博客常用的MarkDown语法啦"><a href="#以上就是我写博客常用的MarkDown语法啦" class="headerlink" title="以上就是我写博客常用的MarkDown语法啦"></a>以上就是我写博客常用的MarkDown语法啦</h4><p>希望大家也可以每天写写字，记录生活<br><img src="/2018/06/11/我的第一篇博客/photo1.jpg"></p><p style="text-align:center;font-size:28px">The End</p>]]></content>
      
      <categories>
          
          <category> summarization </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown语法 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>一支穿云箭</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title></title>
      <link href="/gallery/gallery.json"/>
      <url>/gallery/gallery.json</url>
      <content type="html"><![CDATA[null]]></content>
    </entry>
    
    <entry>
      <title>图库</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
